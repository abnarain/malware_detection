import scipy
from scipy.signal import butter, lfilter, freqz
from scipy.fftpack import fft, fftfreq, fftshift
from scipy import signal,arange
import numpy as np
from numpy import arange
from configs import *

def plot_psd_welch(data,fs,filename,flag):
    # Estimate PSD using Welchs method. Divides the data into overlapping segments, 
    #computing a modified periodogram for each segment and overlapping the periodograms
    
    plt.figure(figsize=(10,10))
    fig, (ax0,ax1) = plt.subplots(nrows=2)
    
    f, Pxx_den = signal.periodogram (data, fs)
    ax0.set_xlabel('frequency [Hz]')
    ax0.set_ylabel('periodogram')
    ax0.plot(f, Pxx_den)
    print "Periodogram"
    print "f is " , f
    print "Pxx_den is ", Pxx_den
     
    f2, Pxx_den2 = signal.welch(data, fs)
    ax1.set_ylabel('PSD [V**2/Hz]')

    print "Welch method "
    print "f2 is ", f2
    print "Pxx_den2 is" , Pxx_den2
    ax1.plot(f2, Pxx_den2)
    if flag==1:
       ax0.set_yscale('log')
       ax1.set_yscale('log')
       ax0.set_ylabel('periodogram (log scale)')
       ax1.set_ylabel('Welch\'s PSD [V**2/Hz] (log scale) ')
    plt.savefig(filename+'.pdf')

def plot_psd(data,fs,filename,flag):
    # Estimate PSD using Welchs method. Divides the data into overlapping segments, 
    #computing a modified periodogram for each segment and overlapping the periodograms
    plt.figure(figsize=(10,10))
    fig, ax0 = plt.subplots(nrows=1)
    f, Pxx_den = signal.periodogram(data, fs)
    ax0.set_xlabel('frequency [Hz]')
    ax0.set_ylabel('periodogram')
    ax0.plot(f, Pxx_den)
    if flag==1:
       ax0.set_yscale('log')
       ax0.set_ylabel('periodogram (log scale)')
       filename= filename+'_log'
    plt.savefig(filename+'.pdf')

def plot_FFTs(x,Fs,filename,flag):
    from scipy.fftpack import fft, fftfreq, fftshift
    """
    Plots a Single-Sided Amplitude Spectrum of y(t)
    """
    N = len(x) # length of the signal
    # frq=fs/N [arange(N)[0:N/2] ]  two sides frequency range
    plt.figure(figsize=(9,9))
    fig, ax2 = plt.subplots(nrows=1)
    Fy= fft(x)*1.0/N
    xf = np.linspace(0.0, fs/2.0, N/2)
    print "freqs are (xf) " , xf
    print "vals are ", np.abs(Fy[0:N/2])
    ax2.plot(xf, np.abs(Fy[0:N/2]))
    ax2.set_xlabel('frequency')
    ax2.set_ylabel('magnitude ')

    if flag==1:
       ax2.set_yscale('log')
       ax2.set_ylabel('|Y(freq)| (log scale) ')
       filename= filename+'_log'
    plt.savefig(filename+'.pdf')


def plot_complex_fft(x, fs, N, outfile_name, flag):
    from scipy.fftpack import fft, fftfreq, fftshift
    plt.figure(figsize=(9,9))
    fig, ax0 = plt.subplots(nrows=1)
    freqs = fftfreq(N, 1.0/fs)
    freqs = fftshift(freqs)
    yf= 1.0/N *fft(x)
    yf = fftshift(yf)
    ax0.plot(freqs,  np.abs(yf))
    #print "freqs is ", freqs
    #print "FFT vals are",  np.abs(yf)
    #ax0.set_xlabel('frequency')
    #ax0.set_ylabel('magnitude')
    if flag==1:
        ax0.set_yscale('log')
        outfile_name= outfile_name+'_log'
    plt.savefig(outfile_name+'.pdf',dpi = 110)

def plot_spectrogram(x, fs, filename,nfft):
    cf=0.0
    plt.figure(figsize=(18,20))
    fig, ax1 = plt.subplots(nrows=1)
    from matplotlib import pylab
    #wrapper = lambda n: np.kaiser(n,40)
    wrapper = lambda n : np.blackman(n)
    #wrapper = lambda n : np.hamming(n)
    #wrapper = lambda n : np.hanning(n)
    #Pxx, freqs, time, im = ax1.specgram(x, NFFT=nfft,  Fs=fs, detrend=pylab.detrend_none, noverlap=nfft/2, window=wrapper(nfft))
    Pxx, freqs, time, im = ax1.specgram(x, Fs=fs, NFFT=nfft)
    ax1.set_title('specgram spectgm'+'NFFT= %d'%nfft)
    #ax3.axis('tight')
    #labels = [item.get_text() for item in ax1.get_xticklabels()]
    ax1.set_ylabel('frequency(Hz)')
    ax1.set_xlabel('time')
    #ax1.set_ylim(40000,80000.0)
    fig.colorbar(im, ax=ax1).set_label("Amplitude (dB)")
    #ax1.set_xlim(0,7)
    #c=ax1.get_yticks().tolist()
    #print c
    #a=[str(float((i+cf)/1000.0)) for i in c ]
    #print a
    #ax1.set_yticklabels(a)
    #ax1.set_ylim(30,40)
    plt.savefig(filename+'.pdf')

def plot_spectrograms(x, fs, filename,nfft):
    #from matplotlib.colors import BoundaryNorm
    #from matplotlib.ticker import MaxNLocator
    # pick the desired colormap, sensible levels, and define a normalization
    # instance which takes data values and translates those into levels.
    #cmap = plt.get_cmap('PiYG')
    #norm = BoundaryNorm(levels, ncolors=cmap.N, clip=True)
    #im = ax0.pcolormesh(x, y, z, cmap=cmap, norm=norm)
    #fig.colorbar(im, ax=ax0)
    plt.figure(figsize=(20,10))
    fig, (ax1, ax2, ax3) = plt.subplots(nrows=3)
    data, freqs, bins, im = ax1.specgram(x,Fs=fs)
    ax1.set_title('vanilla specgram')
    fig.colorbar(im, ax=ax1)
    #plt.colorbar()
    #print "data is ", data 
    #IMP: "specgram" actually plots 10 * log10(data)...
    z=10 * np.log10(data) 
    # x and y are bounds, so z should be the value *inside* those bounds.
    # Therefore, remove the last value from the z array.
    z = z[:-1, :-1]
    z_min, z_max = -np.abs(z).max(), np.abs(z).max()

    im2=ax2.pcolormesh(bins, freqs, z) #vmin=z_min, vmax=z_max )
    fig.colorbar(im2, ax=ax2)
    ax2.set_title('pcolormesh spectgm')
    from matplotlib import pylab
    #Pxx, freqs, bins, im = ax3.specgram(x,Fs=fs)
    Pxx, freqs, bins, im = ax3.specgram(
        x, NFFT=nfft,  Fs=fs, detrend=pylab.detrend_none,
        window=pylab.window_hanning, noverlap=int(nfft * 0.5))
    ax3.set_title('specgram spectgm'+'NFFT= %d'%nfft)
    fig.colorbar(im, ax=ax3).set_label("Amplitude (dB)")
    #print "Pxx is ", Pxx
    #ax3.axis('tight')
    #ax2.axis('tight')
    #ax1.axis('tight')
    plt.savefig(filename+'.pdf')

def butter_lowpass(cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return b, a
    #order = 6
    #cutoff = 190000  # desired cutoff frequency of the filter, Hz
    # Get the filter coefficients so we can check its frequency response.
    #b, a = butter_lowpass(cutoff, fs, order)
    ## Plot the frequency response.
    #w, h = freqz(b, a, worN=8000)

def butter_lowpass(cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return b, a

def butter_lowpass_filter(data, cutoff, fs, order=5):
    b, a = butter_lowpass(cutoff, fs, order=order)
    y = lfilter(b, a, data)
    ## Plot the frequency response.
    #w, h = freqz(b, a, worN=8000)
    return y


def butter_bandpass(lowcut, highcut, fs, order=5):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return b, a


def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    y = lfilter(b, a, data)
    return y

def testing():
    fs = 1900.0
    N  = 1e5
    amp = 1 #2 * np.sqrt(2)
    noise_power = 0.001 * fs / 2
    time = np.arange(N) / fs
    freq = 200 #np.linspace(1e3, 2e3, N)
    x = amp * np.sin(2*np.pi*300*time)
    #x += amp * np.sin(2*np.pi*freq*time)
    x += amp * np.sin(2*np.pi*600*time)
    x += amp * np.sin(2*np.pi*900*time)
    #x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
    
    #plot_FFTs(x,fs,'fft_real',0)
    #plot_complex_fft(x, fs, len(x), 'fft_complex' , 0)
    #plot_psd(x,fs,'power_spectral_density',0) 
    
    #plot_spectrograms(x, fs, 'spectrogram_2048', 2048)
    #peak_indexes=signal.find_peaks_cwt(x, np.arange(1,20))
    #print "peak indices are ", x[peak_indexes]


