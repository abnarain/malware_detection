import scipy, getopt, sys, os, pywt, pylab
import math
from matplotlib import pyplot as plt
from scipy.signal import butter, lfilter, freqz
from scipy.fftpack import fft, fftfreq, fftshift
from scipy import signal,arange
from spectral_analysis import *
#sys.path.append(os.path.abspath("/tmp/pywt/demo"))

import numpy as np

def butter_bandpass(lowcut, highcut, fs, order=5):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return b, a


def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    y = lfilter(b, a, data)
    return y


def dwt_swt_plot(data, w, filename,DWT,mode='sp1',lev=4):
    w = pywt.Wavelet(w)
    a = data
    ca = []
    cd = []

    if DWT:
        for i in xrange(5):
            (a, d) = pywt.dwt(a, w, mode=mode)
            ca.append(a)
            cd.append(d)
    else:
        coeffs = pywt.swt(data, w) #level=lev # [(cA5, cD5), ..., (cA1, cD1)]
        for a, d in reversed(coeffs):
            ca.append(a)
            cd.append(d)
                
    pylab.figure()
    ax_main = pylab.subplot(len(ca) + 1, 1, 1)
    pylab.title(filename)
    ax_main.plot(data)
    pylab.xlim(0, len(data) - 1)
    
    for i, x in enumerate(ca):
        ax = pylab.subplot(len(ca) + 1, 2, 3 + i * 2)
        ax.plot(x, 'r')
        if DWT:
            pylab.xlim(0, len(x) - 1)
        else:
            pylab.xlim(w.dec_len * i, len(x) - 1 - w.dec_len * i)
            pylab.ylabel("A%d" % (i + 1))
                        
    for i, x in enumerate(cd):
        ax = pylab.subplot(len(cd) + 1, 2, 4 + i * 2)
        ax.plot(x, 'g')
        pylab.xlim(0, len(x) - 1)
        if DWT:
            pylab.ylim(min(0, 1.4 * min(x)), max(0, 1.4 * max(x)))
        else:  # SWT
            pylab.ylim(
                min(0, 2 * min(
                    x[w.dec_len * (1 + i):len(x) - w.dec_len * (1 + i)])),
                max(0, 2 * max(
                    x[w.dec_len * (1 + i):len(x) - w.dec_len * (1 + i)]))
                                                                )
            pylab.ylabel("D%d" % (i + 1))
            
    pylab.savefig(filename+'.pdf')
                                                                
def filereader(filename,fs):
    z= scipy.fromfile(open(filename), dtype=scipy.complex64)
    print "length of total z= ", len(z)
    # dtype with scipy.int16, scipy.int32, scipy.float32, scipy.complex64 or whatever type you were using.
    mag, phase,x,y = [], [], [], []
    #'''
    start_sec=2.00
    end_sec=2.4
    z_needed = z[start_sec*fs: end_sec*fs]
    z=z_needed
    #'''
    len_z = int(len(z))
    print "length of needed z= ", len(z)
    log_z= math.log(len_z,2)
    len_z= int(2**log_z)
    for i in range(0, len_z):
        mag.append(np.absolute(z[i]))
        #x.append(z[i].real)
        #y.append(z[i].imag)
        #phase.append(np.angle(z[i]))
        
    return [x,y,mag, phase,z]


def scalogram_levels(data, fs, filename, wv='sym5' ):
    from pywt import WaveletPacket
    wp = WaveletPacket(data, wavelet=wv , maxlevel=2)
    pylab.bone()
    x = np.arange(len(data))/fs
    pylab.subplot(wp.maxlevel + 1, 1, 1)
    pylab.plot(x,data, 'k')
    cm = plt.get_cmap('PiYG')
    #pylab.xlim(0, len(data) - 1)
    pylab.title("Wavelet packet coefficients")
    #ax = pylab.subplot(wp.maxlevel + 1, 1, 1+1)
    for i in range(1, wp.maxlevel + 1):
        ax = pylab.subplot(wp.maxlevel + 1, 1, i + 1)
        nodes = wp.get_level(i, "freq")
        nodes.reverse()
        labels = [n.path for n in nodes]
        values = -abs(np.array([n.data for n in nodes]))
        pylab.imshow(values, interpolation='nearest', aspect='auto',  origin="lower") #extent=[0,1,2,len(values)])
        pylab.yticks(np.arange(len(labels) - 0.5, -0.5, -1), labels)
        pylab.setp(ax.get_xticklabels(), visible=False)
    pylab.savefig(filename+'_'+wv+'.pdf')
    
def scalogram(data, fs, filename,level=4,order="freq",wv='sym5'):
    from pywt import WaveletPacket
    x = np.arange(len(data))/fs
    cm = plt.get_cmap('prism')
    wp = WaveletPacket(data,wavelet=wv , maxlevel=level)
    nodes = wp.get_level(level, order=order)
    labels = [n.path for n in nodes]
    values = pylab.array([n.data for n in nodes], 'd')
    values = abs(values)
    f = pylab.figure()
    f.subplots_adjust(hspace=0.2, bottom=.03, left=.07, right=.97, top=.92)
    pylab.subplot(2, 1, 1)
    pylab.title("signal")
    pylab.plot(x, data, 'b')
    pylab.xlim(0, x[-1])
    
    ax = pylab.subplot(2, 1, 2)
    pylab.title("Wavelet packet coefficients at level %d" % level)
    pylab.imshow(values, interpolation="nearest", cmap=cm, aspect="auto",
                 origin="lower", extent=[0, 1, 0, len(values)])
    pylab.yticks(pylab.arange(0.5, len(labels) + 0.5), labels)
    pylab.savefig(filename+'_'+wv+'.pdf')


def mlpy_cwt(x, fs, filename, wv='morlet' ):
    from matplotlib import pyplot as plt
    import mlpy.wavelet as wave
    omega0 = 0
    #fs=1e6
    fact=2048
    t = np.arange(len(x)) / fs
    #scales = wave.autoscales(N=x.shape[0], dt=1/fs, dj=0.4875, wf=wv, p=omega0)
    #X = wave.cwt(x=x, dt=1/fs, scales=scales, wf=wv, p=omega0)

    scales = wave.autoscales(N=x.shape[0], dt=1.0/fs, dj=.025, wf=wv, p=omega0)
    X = wave.cwt(x=x, dt=1/fs, scales=scales, wf=wv, p=omega0)
    
    fig = plt.figure(1)
    ax1 = plt.subplot(2,1,1)
    p1 = ax1.plot(t,x)
    ax1.autoscale_view(tight=True)
    ax2 = plt.subplot(2,1,2)
    freq = (omega0 + np.sqrt(2.0 + omega0 ** 2)) / (4 * np.pi * scales[1:])
        #print "frequencies are ", freq
    freqs=[math.pow(i,-1) for i in wave.fourier_from_scales(scales, wv, omega0)]
            #print "api freqs are ", freqs
    p2 = ax2.imshow(np.abs(X), interpolation='nearest',aspect='auto', extent=[t[0], t[-1], freq[-1], freq[0]], vmax=abs(X).max(), vmin=-abs(X).max()  )
    twin_ax = ax2.twinx()
    twin_ax.set_xlim(t[0], t[-1])
    twin_ax.set_ylim(freq[-1], freq[0])
    twin_ax.set_yscale('log')
    ax2.tick_params(which='both', labelleft=False, left=False)
    twin_ax.tick_params(which='both', labelleft=True, left=True, labelright=False)
    
    #fig.colorbar(p2)
    fig.savefig(filename+'_'+wv+'.pdf')
    fig.clf()
    
    
def wigner_ville_dist(mag):
    from tftb.processing import WignerVilleDistribution
    wvd = WignerVilleDistribution(mag)
    wvd.run()
    wvd.plot(kind="contour" )#, scale="log")
    #wvd.plot(kind='contour', sqmod=True, show_tf=True,scale="log")
    
def denoise(nblck,filename,mode='sym', wv='sym5' ):
    from statsmodels.robust import mad
    #noisy_coefs = pywt.wavedec(nblck, 'sym5', level=5, mode='per')
    noisy_coefs = pywt.wavedec(nblck, wavelet=wv,   mode=mode) #level=5,  #dwt is for single level decomposition; wavedecoding is for more levels
    sigma = mad(noisy_coefs[-1])
    #uthresh=np.std(ca)/2
    uthresh = sigma*np.sqrt(2*np.log(len(nblck)))
    denoised = noisy_coefs[:]
    denoised[1:] = [pywt.threshold(i, value=uthresh,mode='soft') for i in denoised[1:]]
    signal = pywt.waverec(denoised, wavelet=wv, mode=mode)
    from matplotlib import pyplot as plt
    fig, axes = plt.subplots(1, 2, sharey=True, sharex=True,figsize=(8,4))
    ax1, ax2 = axes
    
    ax1.plot(signal)
    #ax1.set_xlim(0,2**10)
    ax1.set_title("Recovered Signal")
    ax1.margins(.1)
    
    ax2.plot(nblck)
    ax2.set_title("Noisy Signal")
    
    for ax in fig.axes:
        ax.tick_params(labelbottom=False, top=False, bottom=False, left=False,       right=False)
    fig.tight_layout()
    fig.savefig(filename+'_'+wv+'.pdf')
    plt.clf()
    return signal
    

def aren_wavelet(x,filename,fs):
    '''
    Does the same continuous wavelet transmform as the mlpy_cwt
    '''
    from wavelets import WaveletAnalysis
    dt=1/fs
    wa = WaveletAnalysis(x, dt=dt)
    # wavelet power spectrum
    power = wa.wavelet_power
    # scales
    scales = wa.scales
    import mlpy.wavelet as wave
    freqs=[math.pow(i,-1) for i in wave.fourier_from_scales(scales, 'morlet',2)]
    # associated time vector
    t = wa.time
    # reconstruction of the original data
    rx = wa.reconstruction()

    fig, ax = plt.subplots()
    T, S = np.meshgrid(t, scales)
    ax.contourf(T, S, power)
    #ax.set_ylim(freqs[-1],freqs[0])
    #ax.set_yscale('log')
    fig.savefig(filename+'.pdf')
                                                                                    
def mtspec_wigner_ville(data,fs,filename):
    from mtspec import mtspec, wigner_ville_spectrum
    fig = plt.figure()
    
    t = np.arange(len(data)) / fs
    ax1 = fig.add_axes([0.2,0.75, 0.79, 0.23])
    ax1.plot(t,data, color="0.3")
    #ax1.set_xlim(0, len(data))
    ax2 = fig.add_axes([0.06,0.02,0.13,0.69])
    spec, freq = mtspec(data, 10, 3.5)
    print "freq is ", freq
    ax2.plot(spec, freq, color="0.3")
    ax2.set_xlim(0, spec.max())
    ax2.set_ylim(freq[0], freq[-1])
    ax2.set_xticks([])
    wv = wigner_ville_spectrum(data, 10, 3.5, smoothing_filter='gauss')
    ax3 = fig.add_axes([0.2, 0.02, 0.79, 0.69])
    ax3.set_yticks([])
    ax1.set_xticks([])
    ax3.imshow(np.sqrt(abs(wv)), interpolation='lanczos', aspect='auto')
    plt.savefig(filename+'.pdf')
                                                                        
def all_in_one(x, fs, filename, wv='morlet',  nfft=2048 ):
    from matplotlib import pyplot as plt
    import mlpy.wavelet as wave
    omega0 = 0
    #fs=1e6
    t = np.arange(len(x)) / fs
    #scales = wave.autoscales(N=x.shape[0], dt=1/fs, dj=0.4875, wf=wv, p=omega0)
    #X = wave.cwt(x=x, dt=1/fs, scales=scales, wf=wv, p=omega0)
                                
    scales = wave.autoscales(N=x.shape[0], dt=1.0/fs, dj=.025, wf=wv, p=omega0)
    X = wave.cwt(x=x, dt=1/fs, scales=scales, wf=wv, p=omega0)
    
    fig = plt.figure(1)
    
    ax1 = plt.subplot(3,1,1)
    p1 = ax1.plot(t,x)
    ax1.autoscale_view(tight=True)
    ax2 = plt.subplot(3,1,2)
    freq = (omega0 + np.sqrt(2.0 + omega0 ** 2)) / (4 * np.pi * scales[1:])
    #print "frequencies are ", freq
    freqs=[math.pow(i,-1) for i in wave.fourier_from_scales(scales, wv, omega0)]
    #print "api freqs are ", freqs
    p2 = ax2.imshow(np.abs(X), interpolation='nearest',aspect='auto', extent=[t[0], t[-1], freq[-1], freq[0]], vmax=abs(X).max(), vmin=-abs(X).max()  )
    twin_ax = ax2.twinx()
    twin_ax.set_xlim(t[0], t[-1])
    twin_ax.set_ylim(freq[-1], freq[0])
    twin_ax.set_yscale('log')
    ax2.tick_params(which='both', labelleft=False, left=False)
    twin_ax.tick_params(which='both', labelleft=True, left=True, labelright=False)
    #fig.colorbar(p2, ax=ax2).set_label("Amplitude (dB)") #fig.colorbar(p2)
    
    ax3 = plt.subplot(3,1,3)
    wrapper = lambda fn : np.blackman(fn)
    #wrapper = lambda n : np.hamming(n)
    #wrapper = lambda n : np.hanning(n)
    Pxx, freqs, time, im = ax3.specgram(x, NFFT=nfft,  Fs=fs, detrend=pylab.detrend_none, window=wrapper(nfft), noverlap=nfft/2)
    #Pxx, freqs, time, im = ax3.specgram(x, Fs=fs, NFFT=nfft)
    #fig.colorbar(im, ax=ax3).set_label("Amplitude (dB)")
    ax3.set_xlim(t[0], t[-1])
    fig.savefig(filename+'_all'+'.pdf')
    fig.clf()
    
def main(argv):
    inputfile=''
    noisefile,outputfile='',''
    noiseflag,inputflag=0,0
    try:
        opts, args = getopt.getopt(argv,"h:i:n:o:",["ifile=","nfile=","ofile"])
    except getopt.GetoptError:
        print 'file.py -i <inputfile> -n <noisefile> -o <outputfile> '
        sys.exit(2)
        
    for opt, arg in opts:
        print opt ,arg,
        if opt == '-h':
            print 'file.py -i <inputfile> -n <noisefile> -o <outputfile>'
            sys.exit()
        elif opt in ("-i", "--ifile"):
            inputfile = arg
            inputflag=1
        elif opt in ("-n", "--nfile"):
            noisefile = arg
            noiseflag=1
        elif opt in ("-o", "--ofile"):
            outputfile = arg
        else:
            print "check help for usage"
            sys.exit()
            
    print "input file is ", inputfile
    lower_cut = 30.0*1000
    upper_cut = 80.0*1000
    
    #fs=400e3
    fs=500e3
    #fs=10e6
    [x,y, mag, phase,z] = filereader(inputfile,int(fs))
    #mag = butter_bandpass_filter(mag, lower_cut, upper_cut, fs, order=6)
    #yhat = savitzky_golay(mag, 51, 3)
    '''
    fs = 1024.0 # sample rate 
    mag = [ np.sin(2*np.pi*2 * i/fs) + np.sin(2*np.pi*40 * i/fs) + np.sin(2*np.pi*50 * i/fs) for i in np.arange(fs)]
    #mag += [ np.sin(2*np.pi*f2 * i/fs) for i in np.arange(fs)]
    mag += [ np.sin(2*np.pi*450 * i/fs) + np.sin(2*np.pi*200 * i/fs) + np.sin(2*np.pi*100 * i/fs) for i in np.arange(fs)]
    noise = np.random.normal(0, 0.1, 2*fs)
    mag1 = [ np.sin(2*np.pi*5 * i/fs) for i in np.arange(2*fs)]
    mag = noise+mag + mag1 
    '''
    #pylab.plot(mag)
    #pylab.show()
    #for mode_name in ['zpd', 'cpd', 'sym', 'ppd', 'sp1', 'per']:
    #    mode = getattr(pywt.MODES, mode_name)
    '''
    for family in pywt.families():
        for wavelet in pywt.wavelist(family):
            print wavelet
            #sig=denoise(mag,outputfile+'_'+wavelet+'_denoise')
            #plot_spectrogram(mag, fs, outputfile+'_'+wavelet+'_orig', 2048)
            #plot_spectrogram(sig, fs, outputfile+'_'+wavelet+'_denoised', 2048)
            dwt_swt_plot(mag,wavelet,outputfile+'_'+wavelet+'_dtw',1)
            dwt_swt_plot(mag,wavelet,outputfile+'_'+wavelet+'_stw',0)
            scalogram(mag,fs,outputfile+'_'+wavelet+'_scalogram',wavelet)

    '''
    #mlpy_cwt(np.array(mag),fs,outputfile+'_morlet_cwt')
    #mlpy_cwt(np.array(mag),fs,outputfile+'_paul_cwt','paul')
    #mlpy_cwt(np.array(mag),fs,outputfile+'_dog_cwt','dog')
    #all_in_one(np.array(mag),fs,outputfile,'dog', 512 )
                                        
    #scalogram_levels(mag,fs,outputfile+'_scalogram')
    mtspec_wigner_ville(np.array(mag),fs,outputfile+'mtspec_wv')
    #aren_wavelet(np.array(mag),outputfile+'_aren_cwt',fs)
    #wigner_ville_dist(mag)

if __name__=='__main__':
    main(sys.argv[1:])
