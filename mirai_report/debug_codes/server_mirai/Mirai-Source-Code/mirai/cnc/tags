!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AccountInfo	database.go	/^type AccountInfo struct {$/;"	t
AddClient	clientList.go	/^func (this *ClientList) AddClient(c *Bot) {$/;"	f
Admin	admin.go	/^type Admin struct {$/;"	t
Api	api.go	/^type Api struct {$/;"	t
Attack	attack.go	/^type Attack struct {$/;"	t
AttackInfo	attack.go	/^type AttackInfo struct {$/;"	t
AttackSend	clientList.go	/^type AttackSend struct {$/;"	t
Bot	bot.go	/^type Bot struct {$/;"	t
Build	attack.go	/^func (this *Attack) Build() ([]byte, error) {$/;"	f
CanLaunchAttack	database.go	/^func (this *Database) CanLaunchAttack(username string, duration uint32, fullCommand string, maxBots int, allowConcurrent int) (bool, error) {$/;"	f
CheckApiCode	database.go	/^func (this *Database) CheckApiCode(apikey string) (bool, AccountInfo) {$/;"	f
ClientList	clientList.go	/^type ClientList struct {$/;"	t
ContainsWhitelistedTargets	database.go	/^func (this *Database) ContainsWhitelistedTargets(attack *Attack) bool {$/;"	f
Count	clientList.go	/^func (this *ClientList) Count() int {$/;"	f
CreateUser	database.go	/^func (this *Database) CreateUser(username string, password string, max_bots int, duration int, cooldown int) bool {$/;"	f
Database	database.go	/^type Database struct {$/;"	t
DatabaseAddr	main.go	/^const DatabaseAddr string   = "127.0.0.1"$/;"	c
DatabasePass	main.go	/^const DatabasePass string   = "sdf"$/;"	c
DatabaseTable	main.go	/^const DatabaseTable string  = "mirai"$/;"	c
DatabaseUser	main.go	/^const DatabaseUser string   = "abhinav"$/;"	c
DelClient	clientList.go	/^func (this *ClientList) DelClient(c *Bot) {$/;"	f
Distribution	clientList.go	/^func (this *ClientList) Distribution() map[string]int {$/;"	f
FlagInfo	attack.go	/^type FlagInfo struct {$/;"	t
Handle	admin.go	/^func (this *Admin) Handle() {$/;"	f
Handle	api.go	/^func (this *Api) Handle() {$/;"	f
Handle	bot.go	/^func (this *Bot) Handle() {$/;"	f
MiraiPrompt	constants.go	/^const MiraiPrompt = `$/;"	c
NewAdmin	admin.go	/^func NewAdmin(conn net.Conn) *Admin {$/;"	f
NewApi	api.go	/^func NewApi(conn net.Conn) *Api {$/;"	f
NewAttack	attack.go	/^func NewAttack(str string, admin int) (*Attack, error) {$/;"	f
NewBot	bot.go	/^func NewBot(conn net.Conn, version byte, source string) *Bot {$/;"	f
NewClientList	clientList.go	/^func NewClientList() *ClientList {$/;"	f
NewDatabase	database.go	/^func NewDatabase(dbAddr string, dbUser string, dbPassword string, dbName string) *Database {$/;"	f
QueueBuf	bot.go	/^func (this *Bot) QueueBuf(buf []byte) {$/;"	f
QueueBuf	clientList.go	/^func (this *ClientList) QueueBuf(buf []byte, maxbots int, botCata string) {$/;"	f
ReadLine	admin.go	/^func (this *Admin) ReadLine(masked bool) (string, error) {$/;"	f
ReadLine	api.go	/^func (this *Api) ReadLine() (string, error) {$/;"	f
TryLogin	database.go	/^func (this *Database) TryLogin(username string, password string) (bool, AccountInfo) {$/;"	f
apiHandler	main.go	/^func apiHandler(conn net.Conn) {$/;"	f
attackInfoLookup	attack.go	/^var attackInfoLookup map[string]AttackInfo = map[string]AttackInfo {$/;"	v
clientList	main.go	/^var clientList *ClientList = NewClientList()$/;"	v
database	main.go	/^var database *Database = NewDatabase(DatabaseAddr, DatabaseUser, DatabasePass, DatabaseTable)$/;"	v
fastCountWorker	clientList.go	/^func (this *ClientList) fastCountWorker() {$/;"	f
flagInfoLookup	attack.go	/^var flagInfoLookup map[string]FlagInfo = map[string]FlagInfo {$/;"	v
initialHandler	main.go	/^func initialHandler(conn net.Conn) {$/;"	f
main	admin.go	/^package main$/;"	p
main	api.go	/^package main$/;"	p
main	attack.go	/^package main$/;"	p
main	bot.go	/^package main$/;"	p
main	clientList.go	/^package main$/;"	p
main	constants.go	/^package main$/;"	p
main	database.go	/^package main$/;"	p
main	main.go	/^func main() {$/;"	f
main	main.go	/^package main$/;"	p
netshift	main.go	/^func netshift(prefix uint32, netmask uint8) uint32 {$/;"	f
readXBytes	main.go	/^func readXBytes(conn net.Conn, buf []byte) (error) {$/;"	f
uint8InSlice	attack.go	/^func uint8InSlice(a uint8, list []uint8) bool {$/;"	f
worker	clientList.go	/^func (this *ClientList) worker() {$/;"	f
