from  matplotlib import pyplot as plt
import numpy as np
import scipy
from scipy import signal
from numpy import arange

def acf(series):
    n = len(series)
    data = np.asarray(series)
    mean = np.mean(data)
    c0 = np.sum((data - mean) ** 2) / float(n)

    def r(h):
        acf_lag = ((data[:n - h] - mean) * (data[h:] - mean)).sum() / float(n) / c0
        return round(acf_lag, 3)
    x = np.arange(n) # Avoiding lag 0 calculation
    acf_coeffs = map(r, x)
    return acf_coeffs


def timeseries(mag,filename,fs,xlab='time',ylab='mag'):
    plt.plot(mag,'b-')
    plt.xlabel(xlab)
    plt.ylabel(ylab)
    plt.title('fs = %s'%(fs))
    plt.savefig( filename+'.pdf')

def autocorr(x):
    result = numpy.correlate(x, x, mode='full')
    return result[result.size/2:]

def correlation_timeseries(sig,filename,xlab='lag',ylab='mag') :
    #ret= autocorr(sig)
    ret = signal.fftconvolve(sig, sig[::-1], mode='full')
    plt.plot(np.arange(-len(sig)+1,len(sig)), ret)
    plt.xlabel(xlab)
    plt.ylabel(ylab)
    plt.savefig(filename+'.pdf')

def hurst(ts):
    from numpy import cumsum, log, polyfit, sqrt, std, subtract
    """Returns the Hurst Exponent of the time series vector ts"""
    # Create the range of lag values
    lags = range(2, 20000)
    # Calculate the array of the variances of the lagged differences
    tau = [sqrt(std(subtract(ts[lag:], ts[:-lag]))) for lag in lags]
    # Use a linear fit to estimate the Hurst Exponent
    poly = polyfit(log(lags), log(tau), 1)

    # Return the Hurst exponent from the polyfit output
    #Create a Gometric Brownian Motion, Mean-Reverting and Trending Series
    #gbm = log(cumsum(randn(100000))+1000)
    #mr = log(randn(100000)+1000)
    #tr = log(cumsum(randn(100000)+1)+1000)
    return poly[0]*2.0

def test_stationarity(mag):
    import statsmodels.api as sm
    test = sm.tsa.adfuller(mag)
    print 'adf: ', test[0]
    print 'p-value: ', test[1]
    print'Critical values: ', test[4]
    if test[0]> test[4]['5%']:
        print "this is stationary"
    else:
        print "not stationary "


def testing():
    fs = 1900.0
    N  = 1e5
    amp = 1 #2 * np.sqrt(2)
    noise_power = 0.001 * fs / 2
    time = np.arange(N) / fs
    freq = 200 #np.linspace(1e3, 2e3, N)
    x = amp * np.sin(2*np.pi*300*time)
    #x += amp * np.sin(2*np.pi*freq*time)
    x += amp * np.sin(2*np.pi*600*time)
    x += amp * np.sin(2*np.pi*900*time)
    #x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
    
    #peak_indexes=signal.find_peaks_cwt(x, np.arange(1,20))
    #print "peak indices are ", x[peak_indexes]
    test_stationarity(x)
    #hurst(x)
    plot_acf_pacf(x,'pacf',1000)

